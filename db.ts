import { DBClient, RawQueryResult } from './queryState';

// ----- Type utility definitions -----

// Utility to simplify complex types for better editor display
type Simplify<T> = { [K in keyof T]: T[K] } & {};

/**
 * Marks a column as generated by the database.
 * Generated columns are automatically optional during inserts.
 */
export type Generated<T> = {
  __generated__: T;
};

/**
 * Represents a database column type with potentially different types for
 * select, insert, and update operations.
 */
export type ColumnType<Select, Insert = Select, Update = Insert> = {
  __select__: Select;
  __insert__: Insert;
  __update__: Update;
};

/**
 * Shorthand for JSON column type. Selects as T, inserts/updates as string.
 */
export type JSONColumnType<T> = ColumnType<T, string, string>;

// ----- Type extraction helpers -----

// Updated SelectType to handle Generated<T>
type SelectType<T> = 
    T extends Generated<infer G> ? G :
    T extends ColumnType<infer S, any, any> ? S : 
    T;

type InsertType<T> = T extends ColumnType<any, infer I, any> ? I : T extends Generated<infer G> ? G | undefined : T;
type UpdateType<T> = T extends ColumnType<any, any, infer U> ? U : T extends Generated<infer G> ? G : T;

// ----- Selectable, Insertable, Updateable types -----

/**
 * Extracts the selectable type for a table (all columns with their select types).
 */
export type Selectable<T> = Simplify<{ [K in keyof T]: SelectType<T[K]> }>;

/**
 * Extracts the insertable type for a table.
 * Generated columns are optional.
 * Columns with optional insert types (e.g., `ColumnType<Date, string | undefined, never>`) are optional.
 * Other non-nullable columns are required.
 */
type RequiredInsertableKeys<T> = {
  [K in keyof T]: T[K] extends Generated<any> ? never :
                 T[K] extends ColumnType<any, infer I, any> ? (undefined extends I ? never : K) :
                 (null extends T[K] ? never : undefined extends T[K] ? never : K);
}[keyof T];

type OptionalInsertableKeys<T> = Exclude<keyof T, RequiredInsertableKeys<T> | { [K in keyof T]: T[K] extends Generated<any> ? K : never }[keyof T]>;

export type Insertable<T> = Simplify<
  & { [K in RequiredInsertableKeys<T>]: InsertType<T[K]> }
  & { [K in OptionalInsertableKeys<T>]?: InsertType<T[K]> }
>;

/**
 * Extracts the updateable type for a table.
 * All columns are optional.
 * Columns with `never` as update type (e.g., `ColumnType<Date, any, never>`) are excluded.
 */
type OptionalUpdateableKeys<T> = {
    [K in keyof T]: T[K] extends ColumnType<any, any, infer U>
        ? U extends never ? never : K
        : K // Allow updating non-ColumnType and Generated fields by default
}[keyof T];

export type Updateable<T> = Simplify<
    { [K in OptionalUpdateableKeys<T>]?: UpdateType<T[K]> }
>;

// ----- Database model types -----

export interface TableDefinition { // Base constraint for table types
  [columnName: string]: any;
}
export interface Database { // Base constraint for the main DB type
  [tableName: string]: TableDefinition;
}

// ----- Query builder implementation -----

type WhereOperator = '=' | '!=' | '<' | '<=' | '>' | '>=' | 'like' | 'in' | 'not in' | 'is' | 'is not';
type JoinType = 'inner' | 'left' | 'right' | 'full';

interface WhereCondition {
  column: string;
  operator: WhereOperator;
  value: any;
}

interface JoinClause {
  type: JoinType;
  table: string;
  on: {
    leftColumn: string;
    operator: WhereOperator;
    rightColumn: string;
  };
}

// SelectResult needs more sophisticated handling for specific column selections and joins
// Using Selectable<DB[TB]> for now provides basic table type safety
class QueryBuilder<DB extends Database, TB extends keyof DB, SelectResult = Selectable<DB[TB]>> {
  private client: DBClient;
  private transactionId: string | null;
  private fromTable: string | null = null;
  private selectedColumns: string[] = [];
  private whereConditions: WhereCondition[] = [];
  private limitValue: number | null = null;
  private offsetValue: number | null = null;
  private orderByColumns: { column: string; direction: 'asc' | 'desc' }[] = [];
  private joinClauses: JoinClause[] = [];
  private groupByColumns: string[] = [];
  private isCountQuery = false;
  private isDistinct = false;
  private insertValues: Insertable<DB[TB]>[] | null = null;
  private updateValues: Updateable<DB[TB]> | null = null;
  private isDeleteOperation = false;

  constructor(client: DBClient, transactionId: string | null = null, table?: string) {
    this.client = client;
    this.transactionId = transactionId;
    if (table) {
      this.fromTable = table;
    }
  }

  // ----- Select operations -----
  select<C extends (keyof Selectable<DB[TB]> & string)[]>(...columns: C): QueryBuilder<DB, TB, Pick<Selectable<DB[TB]>, C[number]>> {
    this.selectedColumns = columns as string[];
    return this as any;
  }

  selectAll(): QueryBuilder<DB, TB, Selectable<DB[TB]>> {
    this.selectedColumns = ['*'];
    return this as any; // Cast needed due to SelectResult complexity
  }

  distinct(): this {
    this.isDistinct = true;
    return this;
  }

  count(column: string = '*'): QueryBuilder<DB, TB, { count: number }> {
    this.selectedColumns = [`COUNT(${column}) as count`];
    this.isCountQuery = true;
    return this as any;
  }

  // ----- Where conditions -----
  where<C extends keyof Selectable<DB[TB]> & string>(
    column: C, 
    operator: WhereOperator, 
    // Allow type-safe values based on the column's select type
    value: SelectType<DB[TB][C]> | SelectType<DB[TB][C]>[] 
  ): this {
    this.whereConditions.push({ column, operator, value });
    return this;
  }

  whereEquals<C extends keyof Selectable<DB[TB]> & string>(column: C, value: SelectType<DB[TB][C]>): this {
    return this.where(column, '=', value);
  }

  whereIn<C extends keyof Selectable<DB[TB]> & string>(column: C, values: SelectType<DB[TB][C]>[]): this {
    // Ensure value passed to .where is the array
    this.whereConditions.push({ column, operator: 'in', value: values });
    return this;
  }

  whereLike<C extends keyof Selectable<DB[TB]> & string>(column: C, pattern: string): this {
     // Assuming LIKE operates on string-like columns
    return this.where(column, 'like', pattern as any);
  }

  // ----- Joins -----
  // TODO: Improve join result typing
  join<JoinedTable extends keyof DB>(
    table: JoinedTable & string, 
    leftColumn: keyof Selectable<DB[TB]> & string, 
    operator: WhereOperator, 
    rightColumn: keyof Selectable<DB[JoinedTable]> & string
  ): QueryBuilder<DB, TB | JoinedTable, SelectResult & Partial<Selectable<DB[JoinedTable]>>> {
    this.joinClauses.push({
      type: 'inner',
      table,
      on: { leftColumn, operator, rightColumn }
    });
    return this as any;
  }

  leftJoin<JoinedTable extends keyof DB>(
    table: JoinedTable & string, 
    leftColumn: keyof Selectable<DB[TB]> & string, 
    operator: WhereOperator, 
    rightColumn: keyof Selectable<DB[JoinedTable]> & string
  ): QueryBuilder<DB, TB | JoinedTable, SelectResult & Partial<Selectable<DB[JoinedTable]>>> {
    this.joinClauses.push({
      type: 'left',
      table,
      on: { leftColumn, operator, rightColumn }
    });
    return this as any;
  }

  // ----- Ordering and grouping -----
  orderBy(column: keyof Selectable<DB[TB]> & string, direction: 'asc' | 'desc' = 'asc'): this {
    this.orderByColumns.push({ column, direction });
    return this;
  }

  groupBy(...columns: (keyof Selectable<DB[TB]> & string)[]): this {
    this.groupByColumns = columns as string[];
    return this;
  }

  // ----- Limiting results -----
  limit(limit: number): this {
    this.limitValue = limit;
    return this;
  }

  offset(offset: number): this {
    this.offsetValue = offset;
    return this;
  }

  // ----- Execution methods -----
  async execute(): Promise<SelectResult[]> {
    console.log("___execute", this.transactionId)
    const { sql, params } = this.buildQuery();
    console.log("___execute", sql, params)
    let result;
    if (this.transactionId) {
      result = await this.client.queryWithTransaction<SelectResult>(this.transactionId, sql, params);
    } else {
      result = await this.client.standardQuery<SelectResult>(sql, params);
    }
    
    if (!result.ok || !result.json) {
      throw new Error(`Query failed: Status ${result.status}, Response: ${JSON.stringify(result.json)}`);
    }
    return result.json;
  }

  async executeRaw(): Promise<RawQueryResult> {
    const { sql, params } = this.buildQuery();
    let result;
    if (this.transactionId) {
      const txResult = await this.client.queryWithTransaction<any[]>(this.transactionId, sql, params);
      result = {
        ok: txResult.ok,
        status: txResult.status,
        json: txResult.json ? {
           columns: txResult.json.length > 0 ? Object.keys(txResult.json[0]) : [],
           rows: txResult.json.map(row => Object.values(row)),
           meta: { rows_read: txResult.json.length, rows_written: 0 }
         } : null
      };
    } else {
      result = await this.client.rawQuery(sql, params);
    }

    if (!result.ok || !result.json) {
      throw new Error(`Raw query failed: Status ${result.status}, Response: ${JSON.stringify(result.json)}`);
    }
    return result.json;
  }

  async executeTakeFirst(): Promise<SelectResult | undefined> {
    const results = await this.limit(1).execute();
    return results[0];
  }

  async executeTakeFirstOrThrow(): Promise<SelectResult> {
    const result = await this.executeTakeFirst();
    if (!result) {
      throw new Error('No results found');
    }
    return result;
  }

  // ----- Insert operations -----
  values(records: Insertable<DB[TB]> | Insertable<DB[TB]>[]): this {
    console.log("___values", records)
    // Assign directly using the correctly typed variable
    this.insertValues = Array.isArray(records) ? records : [records];
    return this;
  }

  // ----- Update operations -----
  set(values: Updateable<DB[TB]>): this {
    // Assign directly using the correctly typed variable
    this.updateValues = values;
    return this;
  }

  // ----- Query building -----
  buildQuery(): { sql: string, params: any[] } {
    const params: any[] = [];
    if (!this.fromTable) throw new Error('Table must be specified');

    if (this.insertValues) return this.buildInsertQuery(params);
    if (this.updateValues) return this.buildUpdateQuery(params);
    if (this.isDeleteOperation) return this.buildDeleteQuery(params);
    return this.buildSelectQuery(params);
  }

  private buildSelectQuery(params: any[]): { sql: string, params: any[] } {
    let sql = 'SELECT ';
    if (this.isDistinct) sql += 'DISTINCT ';
    sql += this.selectedColumns.length === 0 ? '*' : this.selectedColumns.join(', ');
    sql += ` FROM ${this.fromTable}`;

    for (const join of this.joinClauses) {
      sql += ` ${join.type.toUpperCase()} JOIN ${join.table} ON ${join.on.leftColumn} ${join.on.operator} ${join.on.rightColumn}`;
    }

    if (this.whereConditions.length > 0) {
      sql += ' WHERE ';
      const whereExpressions = this.whereConditions.map(condition => {
        if ((condition.operator === 'in' || condition.operator === 'not in') && Array.isArray(condition.value)) {
          const placeholders = Array(condition.value.length).fill('?').join(', ');
          params.push(...condition.value);
          return `${condition.column} ${condition.operator} (${placeholders})`;
        } else {
          params.push(condition.value);
          return `${condition.column} ${condition.operator} ?`;
        }
      });
      sql += whereExpressions.join(' AND ');
    }

    if (this.groupByColumns.length > 0) sql += ` GROUP BY ${this.groupByColumns.join(', ')}`;
    if (this.orderByColumns.length > 0) sql += ` ORDER BY ${this.orderByColumns.map(o => `${o.column} ${o.direction.toUpperCase()}`).join(', ')}`;
    if (this.limitValue !== null) { sql += ` LIMIT ?`; params.push(this.limitValue); }
    if (this.offsetValue !== null) { sql += ` OFFSET ?`; params.push(this.offsetValue); }

    return { sql, params };
  }

  private buildInsertQuery(params: any[]): { sql: string, params: any[] } {
    if (!this.insertValues || this.insertValues.length === 0) throw new Error('Values required for insert');
    
    const firstRow = this.insertValues[0];
    const columns = Object.keys(firstRow);
    let sql = `INSERT INTO ${this.fromTable} (${columns.join(', ')})`;
    const valuePlaceholders: string[] = [];

    for (const row of this.insertValues) {
      const rowPlaceholders: string[] = [];
      for (const col of columns) {
        rowPlaceholders.push('?');
        params.push(row[col as keyof typeof row]); // Access value safely
      }
      valuePlaceholders.push(`(${rowPlaceholders.join(', ')})`);
    }
    sql += ` VALUES ${valuePlaceholders.join(', ')}`;
    return { sql, params };
  }

  private buildUpdateQuery(params: any[]): { sql: string, params: any[] } {
    if (!this.updateValues || Object.keys(this.updateValues).length === 0) throw new Error('Set values required for update');
    
    const columns = Object.keys(this.updateValues);
    let sql = `UPDATE ${this.fromTable} SET `;
    const setClauses = columns.map(column => {
      params.push(this.updateValues![column as keyof typeof this.updateValues]); // Access value safely
      return `${column} = ?`;
    });
    sql += setClauses.join(', ');

    if (this.whereConditions.length > 0) { // Reuse WHERE logic from select
       sql += ' WHERE ';
      const whereExpressions = this.whereConditions.map(condition => {
        if ((condition.operator === 'in' || condition.operator === 'not in') && Array.isArray(condition.value)) {
          const placeholders = Array(condition.value.length).fill('?').join(', ');
          params.push(...condition.value);
          return `${condition.column} ${condition.operator} (${placeholders})`;
        } else {
          params.push(condition.value);
          return `${condition.column} ${condition.operator} ?`;
        }
      });
      sql += whereExpressions.join(' AND ');
    }
    return { sql, params };
  }

  private buildDeleteQuery(params: any[]): { sql: string, params: any[] } {
    let sql = `DELETE FROM ${this.fromTable}`;
    if (this.whereConditions.length > 0) { // Reuse WHERE logic
       sql += ' WHERE ';
      const whereExpressions = this.whereConditions.map(condition => {
        if ((condition.operator === 'in' || condition.operator === 'not in') && Array.isArray(condition.value)) {
          const placeholders = Array(condition.value.length).fill('?').join(', ');
          params.push(...condition.value);
          return `${condition.column} ${condition.operator} (${placeholders})`;
        } else {
          params.push(condition.value);
          return `${condition.column} ${condition.operator} ?`;
        }
      });
      sql += whereExpressions.join(' AND ');
    }
    return { sql, params };
  }
}

// ----- Database class -----

export class DB<DBType extends Database = Database> {
  private client: DBClient;
  private transactionId: string | null;

  constructor(client: DBClient, transactionId: string | null = null) {
    this.client = client;
    this.transactionId = transactionId;
  }

  // Select Operation
  selectFrom<T extends keyof DBType & string>(table: T): QueryBuilder<DBType, T> {
    return new QueryBuilder<DBType, T>(this.client, this.transactionId, table);
  }

  // Insert Operation - Requires .values()
  insertInto<T extends keyof DBType & string>(table: T): Pick<QueryBuilder<DBType, T>, 'values' | 'execute'> {

    const qb = new QueryBuilder<DBType, T>(this.client, this.transactionId, table);
    // Return only the necessary methods for insert flow
    return {
        values: qb.values.bind(qb),
        execute: qb.execute.bind(qb)
    };
  }

  // Update Operation - Requires .set()
  update<T extends keyof DBType & string>(table: T): Pick<QueryBuilder<DBType, T>, 'set' | 'where' | 'whereEquals' | 'whereIn' | 'whereLike' | 'execute'> {
    const qb = new QueryBuilder<DBType, T>(this.client, this.transactionId, table);
     // Return only the necessary methods for update flow
    return {
        set: qb.set.bind(qb),
        where: qb.where.bind(qb),
        whereEquals: qb.whereEquals.bind(qb),
        whereIn: qb.whereIn.bind(qb),
        whereLike: qb.whereLike.bind(qb),
        execute: qb.execute.bind(qb)
    };
  }

  // Delete Operation
  deleteFrom<T extends keyof DBType & string>(table: T): Pick<QueryBuilder<DBType, T>, 'where' | 'whereEquals' | 'whereIn' | 'whereLike' | 'execute'> {
    const qb = new QueryBuilder<DBType, T>(this.client, this.transactionId, table);
    qb['isDeleteOperation'] = true; // Set internal flag
    // Return only the necessary methods for delete flow
     return {
        where: qb.where.bind(qb),
        whereEquals: qb.whereEquals.bind(qb),
        whereIn: qb.whereIn.bind(qb),
        whereLike: qb.whereLike.bind(qb),
        execute: qb.execute.bind(qb)
    };
  }

  // Raw query execution
  async raw<T = Record<string, any>>(sql: string, params?: any[]): Promise<T[]> {
    let result;
    if (this.transactionId) {
       result = await this.client.queryWithTransaction<T>(this.transactionId, sql, params);
    } else {
       result = await this.client.standardQuery<T>(sql, params);
    }
    if (!result.ok || !result.json) {
      throw new Error(`Raw query failed: Status ${result.status}, Response: ${JSON.stringify(result.json)}`);
    }
    return result.json;
  }

  // Transaction support
  async transaction<T>(callback: (trx: DB<DBType>) => Promise<T>): Promise<T> {
    if (this.transactionId) {
      throw new Error("Cannot begin nested transaction");
    }
    
    const txResult = await this.client.beginTransaction();
    if (!txResult.ok || !txResult.json) {
      throw new Error(`Failed to start transaction: ${JSON.stringify(txResult.json)}`);
    }
    const txId = txResult.json.transaction_id;
    
    const trx = new DB<DBType>(this.client, txId);

    try {
      const result = await callback(trx);
      await this.client.commitTransaction(txId);
      return result;
    } catch (error) {
      console.error("Transaction rolling back due to error:", error);
      await this.client.rollbackTransaction(txId);
      throw error;
    }
  }
}

// ----- Factory function to create DB instance -----

export function createDB<DBType extends Database = Database>(client: DBClient): DB<DBType> {
  return new DB<DBType>(client);
} 